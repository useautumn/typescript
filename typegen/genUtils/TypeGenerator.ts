import { writeFileSync, mkdirSync, existsSync } from "fs";
import path from "path";
import { generateCamelZod } from "./auto-schema-generator";
import type { TypeConfig, TypeGenerationConfig } from "../typeConfigs";

/**
 * Main Type Generator class that orchestrates the conversion process
 * 
 * This class handles the generation of camelCase Zod schemas from snake_case SDK types.
 * It processes multiple type configurations and generates organized output files.
 */
export class TypeGenerator {
  private readonly tsSDKPath: string;
  private readonly targetPath: string;

  constructor(tsSDKPath: string, targetPath: string) {
    this.tsSDKPath = tsSDKPath;
    this.targetPath = targetPath;
  }

  /**
   * Generate all types based on provided configurations
   */
  async generateTypes(config: TypeGenerationConfig): Promise<void> {
    const { configs, outputDir } = config;
    const startTime = Date.now();
    
    console.log(`âš¡ Processing ${configs.length} types...`);
    
    // Generate all types in parallel (no await in the map)
    const startGeneration = Date.now();
    const results = await Promise.allSettled(
      configs.map(async (config, index) => {
        const typeStart = Date.now();
        try {
          this.generateSingleType(config);
          return { config, success: true as const };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(`âŒ Failed ${config.targetName}: ${errorMessage}`);
          return { config, success: false as const, error: errorMessage };
        }
      })
    );
    
    const endGeneration = Date.now();

    // Extract results from Promise.allSettled
    const processedResults = results.map(result => 
      result.status === 'fulfilled' ? result.value : {
        config: configs[results.indexOf(result)],
        success: false as const,
        error: result.reason?.message || 'Unknown error'
      }
    );

    // Generate index file and print summary
    const duration = Date.now() - startTime;
    this.printSummary(processedResults, duration);
    await this.generateIndexFile(configs, outputDir);
  }

  /**
   * Generate a single type based on configuration
   */
  private generateSingleType(config: TypeConfig): void {
    // Ensure output directory exists
    const outputDir = path.dirname(config.targetFile);
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    // Generate the camelCase Zod schema
    generateCamelZod({
      inputFile: config.sourceFile,
      typeName: config.sourceName,
      outputFile: config.targetFile,
      camelCase: true,
      omitFields: config.omitFields,
      extendFields: config.extendFields,
    });
  }

  /**
   * Generate an index file that exports all generated types
   */
  private async generateIndexFile(configs: TypeConfig[], outputDir: string): Promise<void> {
    const indexPath = path.join(this.targetPath, outputDir, "index.ts");
    
    const exports = configs.map(config => {
      const fileName = path.basename(config.targetFile, '.ts');
      return `export * from './${fileName}';`;
    }).join('\n');

    const content = `// Auto-generated exports for all camelCase types
// This file is generated by typegen pipeline
// DO NOT EDIT MANUALLY - changes will be overwritten

${exports}
`;

    writeFileSync(indexPath, content);
    // Removed verbose index file log
  }

  /**
   * Print a summary of the generation process
   */
  private printSummary(
    results: { config: TypeConfig; success: boolean; error?: string }[], 
    duration?: number
  ): void {
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => r.success === false).length;
    
    console.log(`ðŸ“Š ${successful} successful, ${failed} failed (${duration}ms)`);
    
    if (failed > 0) {
      console.log(`\nâŒ Failed generations:`);
      results.filter(r => !r.success).forEach(r => {
        console.log(`   - ${r.config.sourceName}: ${r.error}`);
      });
    }
  }
}